import { ConfigService } from '@nestjs/config';
import { Connection, FindOneOptions, Repository } from 'typeorm';
import { Category } from '../category/entities/category.entity';
import { CertificateService } from '../certificate/certificate.service';
import { Certificate } from '../certificate/entities/certificate.entity';
import { SendGridService } from '../notification/sendgrid.service';
import { Question } from '../question/entities/question.entity';
import { Section } from '../section/entities/section.entity';
import { IPage, IPagination } from '../shared/interfaces/page.interface';
import { User } from '../users/entities/user.entity';
import { AddAssigneesDto } from './dto/add-assignees.dto';
import { ApplicationFilterOptionsDto } from './dto/application-filter-options.dto';
import { CreateOrUpdateAnswersDto } from './dto/create-answer.dto';
import { CreateApplicationDto } from './dto/create-application.dto';
import { ReviewAnswersDto } from './dto/update-answer-status.dto';
import { UpdateApplicationDto } from './dto/update-application.dto';
import { Answer } from './entities/answer.entity';
import { Application } from './entities/application.entity';
import { EAnswerStatus, EApplicationStatus } from './enums';
import { IApplication } from './interfaces/application.interface';
export declare class ApplicationService {
    private readonly applicationRepo;
    private readonly categoryRepo;
    private readonly sectionRepo;
    private readonly questionRepo;
    private readonly answerRepo;
    private readonly userRepo;
    private readonly certificateRepo;
    private sendgridService;
    private configService;
    private certificateService;
    private readonly connection;
    constructor(applicationRepo: Repository<Application>, categoryRepo: Repository<Category>, sectionRepo: Repository<Section>, questionRepo: Repository<Question>, answerRepo: Repository<Answer>, userRepo: Repository<User>, certificateRepo: Repository<Certificate>, sendgridService: SendGridService, configService: ConfigService, certificateService: CertificateService, connection: Connection);
    create(createApplicationDto: CreateApplicationDto, user: User): Promise<Application>;
    createOrUpdateAnswers(id: number, dto: CreateOrUpdateAnswersDto): Promise<Application>;
    findAll(user: User, options: IPagination, { sort, ...filterOptions }: ApplicationFilterOptionsDto): Promise<IPage<Application>>;
    findLatestPending(user: User): Promise<Application>;
    findCurrentApplicationOrCertificate(user: User): Promise<{
        ongoingApplication: number;
        currentCertificate: number;
    }>;
    findDeniedAnswers(id: number): Promise<Application>;
    findQuestions(categoryId: number, sectionId?: number): Promise<Question[]>;
    findOne(options: FindOneOptions<Application>): Promise<IApplication>;
    update(id: number, updateApplicationDto: UpdateApplicationDto, user: User): Promise<Application>;
    updateStatus(id: number, status: Exclude<EApplicationStatus, EApplicationStatus.SUBMITTED | EApplicationStatus.PENDING>, setupFee: number, subscriptionFee: number): Promise<Application>;
    addAssignees(id: number, addAssigneesDto: AddAssigneesDto): Promise<Application>;
    removeAssignee(id: number, assigneeId: number): Promise<Application>;
    updateAnswerStatus(id: number, status: EAnswerStatus, feedback?: string): Promise<Application>;
    reviewAnswers(id: number, dto: ReviewAnswersDto): Promise<void>;
    submit(id: number, user: User): Promise<void>;
    remove(id: number): Promise<void>;
    exportAllAnswersToExcel(categoryId?: number): Promise<{
        fileName: string;
        buffer: any;
    }>;
}
